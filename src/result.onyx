package postgres

use core {
    runtime, alloc, conv
}

Result :: struct {
    handle: PGresult;
}

#inject
Result.status :: (res: Result) => PQresultStatus(res.handle);

#inject
Result.ntuples :: (res: Result) => PQntuples(res.handle);

#inject
Result.nfields :: (res: Result) => PQnfields(res.handle);

#inject
Result.binary_tuples :: (res: Result) => PQbinaryTuples(res.handle);

#inject
Result.fname :: (res: Result, field_num: i32) =>
    PQfname(res.handle, field_num) |> cptru8_to_str(context.temp_allocator);

#inject
Result.fnumber :: (res: Result, field_name: str) =>
    PQfnumber(res.handle, str_to_cstr(field_name));

#inject @Optimize
Result.get_value :: (res: Result, tuple_num, field_num: i32) =>
    PQgetvalue(res.handle, tuple_num, field_num)
    |> cptru8_to_str(context.temp_allocator);

#inject
Result.get_length :: (res: Result, tuple_num, field_num: i32) =>
    PQgetlength(res.handle, tuple_num, field_num);

#inject
Result.get_is_null :: (res: Result, tuple_num, field_num: i32) =>
    PQgetisnull(res.handle, tuple_num, field_num);

#inject
Result.nparams :: (res: Result) => PQnparams(res.handle);

#inject
Result.paramtype :: (res: Result, param_num: i32) =>
    PQparamtype(res.handle, param_num);

#inject
Result.clear :: (res: Result) => PQclear(res.handle);

#inject
Result.one_as :: macro (res: Result, $T: type_expr, string_allocator := context.allocator) -> T {
    result_to_object :: result_to_object

    t: T;
    result_to_object(res, 0, T, ~~ ^t, string_allocator);
    return t;
}

#inject
Result.all_as :: macro (res: Result, $T: type_expr, string_allocator := context.allocator) -> [] T {
    result_to_object :: result_to_object

    rows := res->ntuples();
    ret := make([] T, rows);

    info := core.runtime.info.get_type_info(T);
    if info.kind != .Struct do return .[];

    for row: rows {
        base := cast(^u8) (^ret[row]);
        result_to_object(res, row, T, base, string_allocator);
    }

    return ret;
}


#local
result_to_object :: (res: Result, row: u32, type: type_expr, data: ^u8, string_allocator := context.allocator) {
    for col: res->nfields() {
        @Optimize
        member := runtime.info.get_struct_member(type, res->fname(col));

        if member.type == str {
            *cast(^str) (data + member.offset) = PQgetvalue(res.handle, row, col)
                                                 |> cptru8_to_str(string_allocator);
        } else {
            conv.parse_any(data + member.offset, member.type,
                res->get_value(row, col), string_allocator=string_allocator);
        }
    }
}
